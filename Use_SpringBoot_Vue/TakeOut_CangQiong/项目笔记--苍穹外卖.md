# 项目框架

## 模块划分【Module层面】

项目一共划分了三个模块：sky-common、sky-pojo、sky-server，分别负责：放置公共方法相关代码、放置实体类相关代码、放置server服务相关代码

### sky-common模块

sky-common模块下主要放置一些公共方法或常量数据，这些在sky-server模块的不同功能中都可能用到。

sky-common模块下主要的Package分类如下：

|    Package    | 用途                                                         |
| :-----------: | ------------------------------------------------------------ |
|  `constant`   | 存储一些常量数据：属性名常量、消息常量、密码常量、状态常量。<br />避免在代码中直接写入对应字符串内容，多个地方书写，不便于更改 |
|   `context`   | 使用`ThreadLocal`定义一个存储信息的方法，供上下文调用<br />登录时携带的用户`id`信息，在`server`模块其他功能的时候用到，可以直接获取 |
| `enumeration` | 用枚举定义常量，在自定义注解的时候用到                       |
|  `exception`  | 自定义异常类，在具体业务逻辑梳理时，在可能出现异常的情况中抛出 |
|    `json`     | 自定义转换器，实现`json`对象和`java`对象之间的相互转化       |
| `properties`  | 定义一些`javabean`对象，将配置文件中的相关数据绑定到这些bean对象上，并将其注入到spring容器中 |
|   `result`    | 定义后端统一返回结果的类                                     |
|    `utils`    | 定义`sky-service`模块中，特定功能会用到的工具类：阿里云OSS、HttpClient、Jwt登录、微信支付等 |



### sky-pojo模块

sky-pojo模块主要放置一些实体类对象，用于封装数据。

根据Package类别，主要分为以下三类：

| Package  | 用途                                                         |
| :------: | ------------------------------------------------------------ |
|  `dto`   | `Data Transfer Object`，封装前端页面传送到后端接口的数据为`javaBean`<br />原则一般是：页面传送什么数据，就封装一个DTO，不主动封装；DTO应该继承entity实体类，并扩充相关字段（也可以不继承） |
| `entity` | 也叫`Persistant Object`，在程序中一般作为数据容器，用来持久化存储数据<br />`entity`中的属性一般要与数据库中的字段一一对应，并且要实现`Serializable`接口 |
|   `vo`   | `View Object`，用于存储展示给前端的数据。vo和dto差不多，都是前端需要哪些数据，就封装哪些数据 |

三个Package下的类，都要实现相关的`set`、`get`方法。`entity`、`vo`下的类，额外实现空参构造对象、全参构造对象。

相关实现可以借助`lombok`包，通过注解完成



### sky-server模块

sky-server是该项目的主要模块，后端所有相关功能，都在这个模块下实现。

照例，按照Package结构梳理一下该模块，模块下现有的一些Package如下：

|    Package    | 用途                                                         |
| :-----------: | ------------------------------------------------------------ |
| `annotation`  | 自定义注解。一般结合AOP面向切面编程的思想                    |
|   `aspect`    | 定义切面方法。使用AOP的思想，在某些方法执行前，统一执行特定的代码内容，为方法做数据准备。<br />例如：更新数据表中带有`updateTime`字段的相关表操作，可以用AOP的思想，统一写入该字段，从而简化代码 |
|   `config`    | 配置类，将相关对象注入到IOC容器中，一般供Controller层调用    |
|   `handler`   | 放置一些全局处理器，比如：全局异常处理器                     |
| `interceptor` | 拦截器，用于拦截特定请求：Controller方法、静态资源方法。<br />在请求进入后端处理前，拦截到该请求，并进行相关操作，比如：登录校验<br />拦截器需要通过WebMvc配置类，注册到SpringMVC框架中，才能生效 |
| `controller`  | 接口层，主要对接用户访问请求。定义不同访问路径下的方法内容。<br />Controller层一般不写业务逻辑，而是简单的写明完成该请求的基本步骤，具体的业务逻辑下放到Service层来写 |
|   `service`   | 业务层，Controller层中业务逻辑的具体实现步骤在该层中体现，一般封装有多个DAO层接口的实现 |
|   `mapper`    | 相当于DAO层，直接与数据库打交道，提供相关接口给Service层     |



## 各模块主要Package内容

各个模块的package中创建的类，多有固定的格式，可以进行参考参考。

### sky-common | constant

定义常量类

```java
public class AutoFillConstant {
    /**
     * 实体类中的方法名称
     */
    public static final String SET_CREATE_TIME = "setCreateTime";
    public static final String SET_UPDATE_TIME = "setUpdateTime";
    public static final String SET_CREATE_USER = "setCreateUser";
    public static final String SET_UPDATE_USER = "setUpdateUser";
}
```

- 定义的状态常量，用的是Integer类，属于引用数据对象



### sky-common | context

定义上下文交互的函数方法

```java
public class BaseContext {

    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }

    public static void removeCurrentId() {
        threadLocal.remove();
    }
}
```

### sky-common | exception

自定义异常类，提供空参和带参构造方法

- 自定义基类异常

```java
public class BaseException extends RuntimeException {

    public BaseException() {
    }

    public BaseException(String msg) {
        super(msg);
    }
}
```

- 自定义具体异常类型，继承基类异常

```java
/**
 * 账号被锁定异常
 */
public class AccountLockedException extends BaseException {

    public AccountLockedException() {
    }

    public AccountLockedException(String msg) {
        super(msg);
    }
}
```

### sky-common | properties

属性配置类，将xml配置文件中的内容装配到java类中，并注入到IOC容器

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "sky.alioss")
@Data
public class AliOssProperties {

    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;
}
```

### sky-common | result

定义接口统一的数据返回类

```java
import lombok.Data;
import java.io.Serializable;

/**
 * 后端统一返回结果
 * @param <T>
 */
@Data
public class Result<T> implements Serializable {

    private Integer code; //编码：1成功，0和其它数字为失败
    private String msg; //错误信息
    private T data; //数据

    public static <T> Result<T> success() {
        Result<T> result = new Result<T>();
        result.code = 1;
        return result;
    }

    public static <T> Result<T> success(T object) {
        Result<T> result = new Result<T>();
        result.data = object;
        result.code = 1;
        return result;
    }

    public static <T> Result<T> error(String msg) {
        Result result = new Result();
        result.msg = msg;
        result.code = 0;
        return result;
    }
}
```

```java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;
import java.util.List;

/**
 * 封装分页查询结果
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable {
    private long total; //总记录数
    private List records; //当前页数据集合
}
```



### sky-pojo | dto

需要有set、get方法。可以没有带参构造方法

```java
import lombok.Data;
import java.io.Serializable;

@Data
public class CategoryDTO implements Serializable {
    //主键
    private Long id;
    //类型 1 菜品分类 2 套餐分类
    private Integer type;
    //分类名称
    private String name;
    //排序
    private Integer sort;
}
```

### sky-pojo | entity

和数据表的表字段一一对应：带参、空参、set、get、builder方法都有

```java
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    //微信用户唯一标识
    private String openid;

    //姓名
    private String name;

    //手机号
    private String phone;

    //性别 0 女 1 男
    private String sex;

    //身份证号
    private String idNumber;

    //头像
    private String avatar;

    //注册时间
    private LocalDateTime createTime;
}
```



### sky-common | vo

同entity，该有的方法都有

```java
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 数据概览
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BusinessDataVO implements Serializable {

    private Double turnover;//营业额

    private Integer validOrderCount;//有效订单数

    private Double orderCompletionRate;//订单完成率

    private Double unitPrice;//平均客单价

    private Integer newUsers;//新增用户数
}
```







# 业务逻辑

> 值得借鉴的地方

## Redis缓存删除 | 简化处理逻辑

**问题描述：**

为了防止用户端访问人数过多，导致数据库出现问题，将菜品、套餐等信息存入Redis缓存，其键值对设置如下：

- 键：菜品、套餐所属的分类id
- 值：每个分类下的所有菜品（或所有套餐）数据，存入List集合，并将集合作为值存入缓存

当批量删除菜品的时候，**常规的实现逻辑是**：

- 找到待删除的菜品所对应的分类id
- 删除对应分类id在Redis缓存中的数据

**实际做法：**

上述常规实现，还需要额外通过菜品信息查询所属分类的id，增加了数据库访问操作。

实际上，菜品的批量删除是管理端相对不频繁的一种操作。因此可以用**实现上的简便代替逻辑上的准确：**

- 在进行批量删除的时候，直接删除所有菜品分类有关的Redis缓存，从而避免额外的数据库查询操作



## 数据表涉及 | 冗余字段设计

**应用场景：**

用户下单后，需要展示详细的订单信息，比如：商品名称、商品图片、订单id、菜品id、口味数据、数量、单价等。

这里面：有逻辑外键、有冗余字段设计，其中：商品名称和商品图片原本是在菜品表里面存储的，但在订单表里面，把他们设计为冗余字段，同时也存进来。

**好处：**

后续订单查询接口就由多表操作变为了单表操作，减少数据库访问次数。



## 业务逻辑 | 用户微信小程序下单

**逻辑流程：**

1. 用户浏览商品，将商品添加到购物车中
2. 用户点击下单按钮，后台进行下单处理：
   1. 将用户信息插入到订单表里面
   2. 将商品信息插入到订单明细表里面
   3. 清空购物车数据
   4. 生成订单数据，并将订单数据返回给前端

**异常处理：**

1. 判断用户地址栏是否为空，若为空，禁止下单
2. 判断用户购物车数据是否为空，若为空，禁止下单

**注意事项：**

1. 下单后清空购物车内容是合理的：淘宝购物的操作逻辑也是这样



# 常用工具类及框架应用注意事项

## 工具类 | 阿里云OSS存储图片

**相关依赖**

```xml
<dependency>
    <groupId>com.aliyun.oss</groupId>
    <artifactId>aliyun-sdk-oss</artifactId>
    <version>3.10.2</version>
</dependency>
```

**项目中涉及到阿里云OSS的相关代码位置及作用**

位置按照：模块（Module）-包（Package）-类名（Class）来写。

|                      位置                      | 作用                                                         |
| :--------------------------------------------: | ------------------------------------------------------------ |
| `sky-common`--`properties`--`AliOssProperties` | 配置属性类，用来提供阿里云OSS相关的基本配置信息：`endpoint、accessKeyId、accessKeySecret、buckerName`。这些数据通过xml配置文件装配到类中，并将该类注入到IOC容器中 |
|      `sky-common`--`utils`--`AliOssUtil`       | 工具类，用来提供阿里云OSS相关的图片上传方法，方法会返回上传后的图片访问路径 |
|   `sky-server`--`config`--`OssConfiguration`   | 配置类，将工具类和配置属性类组合到一起，并注册到IOC容器里面，供相关模块调用 |
|  `sky-server`--`resources`--`application.yml`  | 配置文件，写有配置属性类里面基本属性的具体值                 |



**具体代码实现**：`sky-common`--`properties`--`AliOssProperties`

```java
package com.sky.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component		// 标注Spring管理的Bean，表示将此类标记为Spring容器的一个Bean
@ConfigurationProperties(prefix = "sky.alioss")
@Data
public class AliOssProperties {
    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;
}
```

**具体代码实现**：`sky-common`--`utils`--`AliOssUtil`

```java
package com.sky.utils;

import com.aliyun.oss.ClientException;
import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.OSSException;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import java.io.ByteArrayInputStream;

@Data
@AllArgsConstructor
@Slf4j
public class AliOssUtil {

    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;

    /**
     * 文件上传
     *
     * @param bytes
     * @param objectName
     * @return
     */
    public String upload(byte[] bytes, String objectName) {

        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

        try {
            // 创建PutObject请求。
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
        } catch (OSSException oe) {
            System.out.println("Caught an OSSException, which means your request made it to OSS, "
                    + "but was rejected with an error response for some reason.");
            System.out.println("Error Message:" + oe.getErrorMessage());
            System.out.println("Error Code:" + oe.getErrorCode());
            System.out.println("Request ID:" + oe.getRequestId());
            System.out.println("Host ID:" + oe.getHostId());
        } catch (ClientException ce) {
            System.out.println("Caught an ClientException, which means the client encountered "
                    + "a serious internal problem while trying to communicate with OSS, "
                    + "such as not being able to access the network.");
            System.out.println("Error Message:" + ce.getMessage());
        } finally {
            if (ossClient != null) {
                ossClient.shutdown();
            }
        }
        //文件访问路径规则 https://BucketName.Endpoint/ObjectName
        StringBuilder stringBuilder = new StringBuilder("https://");
        stringBuilder
                .append(bucketName)
                .append(".")
                .append(endpoint)
                .append("/")
                .append(objectName);

        log.info("文件上传到:{}", stringBuilder.toString());
        return stringBuilder.toString();
    }
}
```

**具体代码实现**：`sky-server`--`config`--`OssConfiguration`

```java
package com.sky.config;

import com.sky.properties.AliOssProperties;
import com.sky.utils.AliOssUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 用于创建AliOssUtil对象
 */
@Configuration	// 标志该类是一个配置类，里面声明有一个或多个@Bean方法，Spring容器可以使用这些方法来注入Bean
@Slf4j
public class OssConfiguration {

    /**
     * 创建aliossUtil的bean实例，并且保证全局唯一，不用重复创建
     * @param aliOssProperties
     * @return
     */
    @Bean
    @ConditionalOnMissingBean	// 在没有该Bean的时候，创建并注入到IOC容器：用于保证该Bean全局唯一
    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties){
        log.info("开始创建阿里云文件上传工具类对象：{}", aliOssProperties);
        return new AliOssUtil(aliOssProperties.getEndpoint(),
                aliOssProperties.getAccessKeyId(),
                aliOssProperties.getAccessKeySecret(),
                aliOssProperties.getBucketName());
    }
}
```

**具体代码实现**：`sky-server`--`resources`--`application.yml`

```yml
# application.yml
spring:
  profiles:
    active: dev
    
sky:
  alioss:
    endpoint: ${sky.alioss-gsf.endpoint}
    access-key-id: ${sky.alioss-gsf.access-key-id}
    access-key-secret: ${sky.alioss-gsf.access-key-secret}
    bucket-name: ${sky.alioss-gsf.bucket-name}
    
# application-dev.yml
sky:
  alioss-gsf:
    endpoint: oss-cn-beijing.aliyuncs.com
    bucket-name: sky-take-out-gsf
    access-key-secret: ECyZAfVTC5FuFinbS8vbl6QT4ghWgq
    access-key-id: LTAI5tNdcLQruEKHoHS3atAA
```

**应用示例**

```java
package com.sky.controller.admin;

import com.sky.constant.MessageConstant;
import com.sky.result.Result;
import com.sky.utils.AliOssUtil;
import com.sky.utils.HttpClientUtil;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.UUID;

/**
 * 通用接口
 */
@RestController
@RequestMapping("/admin/common")
@Api(tags = "通用的相关接口")
@Slf4j
public class CommonController {

    @Autowired
    private AliOssUtil aliOssUtil;

    @PostMapping("/upload")
    @ApiOperation("文件上传")
    public Result<String> upload(MultipartFile file){
        log.info("菜品图片文件上传");

        try {
            // 文件原始名
            String originalFilename = file.getOriginalFilename();
            // 截取后缀
            String extension = originalFilename.substring(originalFilename.lastIndexOf("."));
            // 创建新的名字
            String objectname = UUID.randomUUID().toString() + extension;
            // 文件上传
            String filepath = aliOssUtil.upload(file.getBytes(), objectname);
            return Result.success(filepath);
        } catch (Exception e) {
            log.info("文件上传失败：{}", e.getMessage());
        }
        return Result.error(MessageConstant.UPLOAD_FAILED);
    }
}
```





## 工具类 | Jwt令牌生成Token

**相关依赖**

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

**项目中涉及到阿里云OSS的相关代码位置及作用**

位置按照：模块（Module）-包（Package）-类名（Class）来写。

|                     位置                     | 作用                                                         |
| :------------------------------------------: | ------------------------------------------------------------ |
| `sky-common`--`properties`--`JwtProperties`  | 配置属性类，用来提供基本配置信息：`SecretKey、Ttl、TokenName` |
|       `sky-common`--`utils`--`JwtUtil`       | 工具类，用来提供阿里云OSS相关的图片上传方法，方法会返回上传后的图片访问路径 |
| `sky-server`--`resources`--`application.yml` | 配置文件，写有配置属性类里面基本属性的具体值                 |



**具体代码实现**：`sky-common`--`properties`--`JwtProperties`

```java
package com.sky.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "sky.jwt")
@Data
public class JwtProperties {

    /**
     * 管理端员工生成jwt令牌相关配置
     */
    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;

    /**
     * 用户端微信用户生成jwt令牌相关配置
     */
    private String userSecretKey;
    private long userTtl;
    private String userTokenName;
}
```

**具体代码实现**：`sky-common`--`utils`--`JwtUtil`  

```java
package com.sky.utils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.Map;

public class JwtUtil {
    /**
     * 生成jwt
     * 使用Hs256算法, 私匙使用固定秘钥
     *
     * @param secretKey jwt秘钥
     * @param ttlMillis jwt过期时间(毫秒)
     * @param claims    设置的信息
     * @return
     */
    public static String createJWT(String secretKey, long ttlMillis, Map<String, Object> claims) {
        // 指定签名的时候使用的签名算法，也就是header那部分
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

        // 生成JWT的时间
        long expMillis = System.currentTimeMillis() + ttlMillis;
        Date exp = new Date(expMillis);

        // 设置jwt的body
        JwtBuilder builder = Jwts.builder()
                // 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的
                .setClaims(claims)
                // 设置签名使用的签名算法和签名使用的秘钥
                .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))
                // 设置过期时间
                .setExpiration(exp);

        return builder.compact();
    }

    /**
     * Token解密
     *
     * @param secretKey jwt秘钥 此秘钥一定要保留好在服务端, 不能暴露出去, 否则sign就可以被伪造, 如果对接多个客户端建议改造成多个
     * @param token     加密后的token
     * @return
     */
    public static Claims parseJWT(String secretKey, String token) {
        // 得到DefaultJwtParser
        Claims claims = Jwts.parser()
                // 设置签名的秘钥
                .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))
                // 设置需要解析的jwt
                .parseClaimsJws(token).getBody();
        return claims;
    }
}
```

**具体代码实现**：`sky-server`--`resources`--`application.yml`

```yml
# application.yml
sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 72000000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
    # 设置jwt签名加密时使用的秘钥
    user-secret-key: itheima
    # 设置jwt过期时间
    user-ttl: 72000000
    # 设置前端传递过来的令牌名称
    user-token-name: authentication
```

**应用示例**

登录模块，创建Token

```java
@RestController
@RequestMapping("/admin/employee")
@Slf4j
@Api(tags = "员工相关接口")
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;
    @Autowired
    private JwtProperties jwtProperties;

    @PostMapping("/login")
    @ApiOperation(value = "员工登录")
    public Result<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
        log.info("员工登录：{}", employeeLoginDTO);

        Employee employee = employeeService.login(employeeLoginDTO);

        //登录成功后，生成jwt令牌
        Map<String, Object> claims = new HashMap<>();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());		// JwtClaimsConstant.EMP_ID：自定义常量，本质就是字符串：empid
        String token = JwtUtil.createJWT(
                jwtProperties.getAdminSecretKey(),
                jwtProperties.getAdminTtl(),
                claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return Result.success(employeeLoginVO);
    }
}
```

拦截器模块，校验Token

```java
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor {

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) {
            //当前拦截到的不是动态方法，直接放行
            return true;
        }

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try {
            log.info("jwt校验:{}", token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            BaseContext.setCurrentId(empId);
            log.info("当前员工id：{}", empId);
            //3、通过，放行
            return true;
        } catch (Exception ex) {
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        }
    }
}
```



## 工具类 | Redis使用：Spring Data Redis

**相关依赖**

SpringBoot继承了对Redis的使用，SpringBoot版本：2.7.3

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

**项目中涉及到阿里云OSS的相关代码位置及作用**

位置按照：模块（Module）-包（Package）-类名（Class）来写。

|                     位置                     | 作用                                     |
| :------------------------------------------: | ---------------------------------------- |
| `sky-server`--`config`--`RedisConfiguration` | 配置类，将redis模板创建并注入到IOC容器中 |

**具体代码实现**：`sky-server`--`config`--`RedisConfiguration`

```java
package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration {
    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
        log.info("开始创建redis模板类...");
        // 创建RedisTemplate对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 设置连接工厂
        template.setConnectionFactory(redisConnectionFactory);
		// 设置key的序列化，此处还可以设置对value、HashKey、HashValue的序列化
        template.setKeySerializer(new StringRedisSerializer());
        // 返回
        return template;
    }
}
```

**应用示例**

```java
// 注入
@Autowired
private RedisTemplate redisTemplate;

// 调用：写入
redisTemplate.opsForValue().set(key, value)
  
// 调用：读取
Integer status = (Integer) redisTemplate.opsForValue().get(key);
```



## 工具类 | WebSocket应用

**WebSocket介绍**

- WebSocket 是基于 TCP 的一种新的网络协议。
- 它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接， 并进行双向数据传输。

**WebSocket与HTTP的区别**

两者会话创建过程图示：

![image-20240308163245639](https://gitee.com/HMTeenage/image/raw/master/Summary/image-20240308163245639.png)

HTTP协议和WebSocket协议的区别：

|                      HTTP协议                      |         WebSocket协议          |
| :------------------------------------------------: | :----------------------------: |
|                      是短连接                      |            是长连接            |
| 单向通信，基于请求响应模式完成通信响应（信息返回） | 双向通信，可各自发送信息到对方 |
|                   底层：TCP连接                    |         底层：TCP连接          |

**应用场景：**

- 视频弹幕、网页聊天、体育实况更新、股票基金报价实时更新



**相关依赖**

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

**实际应用：用户端（Client）**

```html
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebSocket Demo</title>
</head>
<body>
    <input id="text" type="text" />
    <button onclick="send()">发送消息</button>
    <button onclick="closeWebSocket()">关闭连接</button>
    <div id="message">
    </div>
</body>
<script type="text/javascript">
    var websocket = null;
    var clientId = Math.random().toString(36).substr(2);

    //判断当前浏览器是否支持WebSocket
    if('WebSocket' in window){
        //连接WebSocket节点：clientId就是当前网页创建的WebSocket对象id
        websocket = new WebSocket("ws://localhost:8080/ws/"+clientId);
    }
    else{
        alert('Not support websocket')
    }

    //连接发生错误的回调方法
    websocket.onerror = function(){
        setMessageInnerHTML("error");
    };

    //连接成功建立的回调方法
    websocket.onopen = function(){
        setMessageInnerHTML("连接成功");
    }

    //接收到消息的回调方法
    websocket.onmessage = function(event){
        setMessageInnerHTML(event.data);
    }

    //连接关闭的回调方法
    websocket.onclose = function(){
        setMessageInnerHTML("close");
    }

    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
    window.onbeforeunload = function(){
        websocket.close();
    }

    //将消息显示在网页上
    function setMessageInnerHTML(innerHTML){
        document.getElementById('message').innerHTML += innerHTML + '<br/>';
    }

    //发送消息
    function send(){
        var message = document.getElementById('text').value;
        websocket.send(message);
    }
	
	//关闭连接
    function closeWebSocket() {
        websocket.close();
    }
</script>
</html>
```

- 若客户端创建的WebSocket对象的id是固定的，则两个用户端同时创建连接，只能往最新建立连接的用户端那里发送数据

- 用户端关闭的时候，要主动断开连接，不然服务端会出错
- 用户端接受消息，多是通过回调函数实现



**实际应用：服务端（Server）**

WebSocket的配置类

```java
package com.sky.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

/**
 * WebSocket配置类，用于注册WebSocket的Bean
 */
@Configuration
public class WebSocketConfiguration {

    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }
}
```

WebSocket的工具类

```java
package com.sky.websocket;

import org.springframework.stereotype.Component;

import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

@Component
@ServerEndpoint("/ws/{sid}")
public class WebSocketServer {

    //存放会话对象
    private static Map<String, Session> sessionMap = new HashMap();

    /**
     * 连接建立成功调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam("sid") String sid) {
        System.out.println("客户端：" + sid + "建立连接");
        sessionMap.put(sid, session);
    }

    /**
     * 收到客户端消息后调用的方法
     *
     * @param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, @PathParam("sid") String sid) {
        System.out.println("收到来自客户端：" + sid + "的信息:" + message);
    }

    /**
     * 连接关闭调用的方法
     *
     * @param sid
     */
    @OnClose
    public void onClose(@PathParam("sid") String sid) {
        System.out.println("连接断开:" + sid);
        sessionMap.remove(sid);
    }

    /**
     * 群发
     *
     * @param message
     */
    public void sendToAllClient(String message) {
        Collection<Session> sessions = sessionMap.values();
        for (Session session : sessions) {
            try {
                //服务器向客户端发送消息
                session.getBasicRemote().sendText(message);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

- 通过不同的注解，让普通Java函数变成回调方法，来处理用户端发送过来的信息
- 自定义的WebSocketServer类要加入IOC容器

**应用：配合Spring Task，完成定时发送数据**

```java
package com.sky.task;

import com.sky.websocket.WebSocketServer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Component
public class WebSocketTask {
    @Autowired
    private WebSocketServer webSocketServer;

    /**
     * 通过WebSocket每隔5秒向客户端发送消息
     */
    @Scheduled(cron = "0/5 * * * * ?")
    public void sendMessageToClient() {
        webSocketServer.sendToAllClient("这是来自服务端的消息：" + 		DateTimeFormatter.ofPattern("HH:mm:ss").format(LocalDateTime.now()));
    }
}
```

## 工具类 | PageHelper



## SpringBoot框架 | @RestController

**简单介绍：**

- @RestController是@Controller和@RequestBody的组合，用于定义控制器，且控制器中每个方法的返回结果为Json或xml格式的数据

**注意事项：**

- 在后端开发中，若接口分为不同的端，比如：管理端、用户端等。
- 为了防止控制器类命名上的重复导致IOC容器识别Bean错误，在使用该注解的时候，记得起别名

```java
@RestController("adminCategoryController")  // 别名
@RequestMapping("/admin/category")
@Api(tags = "分类相关接口")
@Slf4j
public class CategoryController {

    @Autowired
    private CategoryService categoryService;
    
    xxxxxx
}
```



## SpringBoot框架 | Spring Cache使用

**框架介绍：**

- Spring Cache是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。
- Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现，例如：EHCache、Caffeine、Redis

**依赖导入：**

- Spring Cache的依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
    <version>2.7.3</version>
</dependency>
```

- 底层缓存实现的依赖：三个缓存实现，需要用到哪一个，就导入哪一个的依赖即可。注解都是通用的。下边导入Redis的依赖

```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-redis</artifactId>
   <version>2.7.5</version>
</dependency>
```

**相关注解**

|       注解       | 用途                                                         |
| :--------------: | ------------------------------------------------------------ |
| `@EnableCaching` | 放在启动类上，用于开启注解                                   |
|   `@Cacheable`   | 放在Controller的方法上：方法执行前，先看缓存中是否有数据；有，取缓存数据；无，执行方法，将返回结果放入缓存 |
|   `@CachePut`    | 将方法的返回值放入缓存【这个注解用的少，能想到的场景就是：有个方法，专门就是用来取数据并放入缓存的，这个方法调用次数比较少】 |
|  `@CacheEvict`   | 将一条或多条数据从缓存中删除                                 |

**实际应用**

在启动类上加入`@EnableCaching`注解

```java
package com.sky;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
@EnableTransactionManagement //开启注解方式的事务管理
@EnableCaching	// 允许缓存
@Slf4j
public class SkyApplication {
    public static void main(String[] args) {
        SpringApplication.run(SkyApplication.class, args);
        log.info("server started");
    }
}
```

在List类别的方法上加入`@Cacheable`注解。缓存中键的格式：cacheNames_key

```java
@GetMapping("/list")
@ApiOperation("根据分类id查询套餐")
@Cacheable(cacheNames = "setmealCache", key = "#categoryId")
public Result<List<Setmeal>> list(Long categoryId) {
    Setmeal setmeal = new Setmeal();
    setmeal.setCategoryId(categoryId);
    setmeal.setStatus(StatusConstant.ENABLE);

    List<Setmeal> list = setmealService.list(setmeal);
    return Result.success(list);
}
```

在save、delete等方法上加入`@CacheEvict`注解

```java
@PostMapping
@ApiOperation("新增套餐")
@CacheEvict(cacheNames = "setmealCache",key = "#setmealDTO.categoryId")		// 删除指定key的缓存
public Result save(@RequestBody SetmealDTO setmealDTO) {
    setmealService.saveWithDish(setmealDTO);
    return Result.success();
}

@DeleteMapping
@ApiOperation("批量删除套餐")
@CacheEvict(cacheNames = "setmealCache",allEntries = true)		// 删除key特定开头下的所有缓存
public Result delete(@RequestParam List<Long> ids){
    setmealService.deleteBatch(ids);
    return Result.success();
}
```



## SpringBoot框架 | Spring Task使用

**框架介绍：**

- Spring Task是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某段代码逻辑
- 应用场景：信用卡还款提醒、银行贷款提醒、火车票未支付订单、入职纪念日发送通知

**依赖导入：**

- Spring Task没有单独的依赖，默认封装在启动依赖中

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <version>2.7.3</version>
</dependency>
```

**相关注解**

|        注解         | 用途                                               |
| :-----------------: | -------------------------------------------------- |
| `@EnableScheduling` | 放在启动类上，允许项目开启定时任务                 |
|    `@Scheduled`     | 放在写有定时业务逻辑的方法上，并写入cron定时表达式 |

**cron定时表达式：**

在线生成cron表达式的网站：[https://cron.qqe2.com/](https://cron.qqe2.com/)

cron表达式组成：

- 是一个字符串
- 由6到7个域组成，每个域中间由空格隔开
- 每个域代表一个含义，分别是：秒 分 时 日 月 周 年（因为周和日无法同时对应，比如：每月的第二周的周一都是不同的日子，因此在指定周的时候，就不能再指定日了；反之，同理，在指定日的时候就不能指定周了）

**实际应用**

在启动类上加入`@EnableScheduling`注解

```java
package com.sky;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
@EnableTransactionManagement //开启注解方式的事务管理
@EnableCaching  // 允许缓存
@EnableScheduling   // 允许定时任务
@Slf4j
public class SkyApplication {
    public static void main(String[] args) {
        SpringApplication.run(SkyApplication.class, args);
        log.info("server started");
    }
}
```

在待定时的业务逻辑代码的方法上，写入`@Scheduled`注解

```java
package com.sky.task;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

@Component	// 自定义的定时类，要加上@Component注解，实例化并注入IOC容器中
@Slf4j
public class OrderTask {
    @Autowired
    private OrderMapper ordersMapper;

    /**
     * 处理超时订单(每分钟触发一次)
     */
    @Scheduled(cron = "0 * * * * ? ")		// 方法上加入写有cron表达式的@Scheduled注解
    public void processTimeoutOrder(){
        LocalDateTime time = LocalDateTime.now().plusMinutes(-15);
        List<Orders> orders = ordersMapper.getByStatusAndOrderTimeLT(Orders.PENDING_PAYMENT, time);

        if(orders != null && !orders.isEmpty()){
            for (Orders order : orders) {
                order.setStatus(Orders.CANCELLED);
                order.setCancelReason("订单超时未支付，自动取消");
                order.setCancelTime(LocalDateTime.now());
                ordersMapper.update(order);
            }
        }
    }
}
```



## SpringBoot框架 | LogBack+Lombok配置日志输出

**描述**

SpringBoot项目默认使用Logback作为日志框架，添加相关依赖后，不需要指定配置文件名称，就会自动识别classpath下的logback-spring.xml文件。

- 项目默认输出到控制台的日志就是由Logback生成。
- 通过引入Lombok框架，在方法上加入`@Slf4j`注解，也可以实现自定义日志内容，并将其打印到控制台。

通过logback.xml配置文件，可以将上述两个框架产生的日志内容输出到文件。

**依赖引入**

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-logging</artifactId>
  <version>2.7.3</version>
</dependency>

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.20</version>
</dependency>
```

**配置文件：logback-spring.xml**

该文件放在`resources`目录下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 -->
<!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true -->
<!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。
                 当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->
<!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->
<configuration  scan="true" scanPeriod="10 seconds">
    <contextName>logback-spring</contextName>

    <!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 -->
    <property name="logging.path" value="logs" />

    <!--0. 日志格式和颜色渲染 -->
    <!-- 彩色日志依赖的渲染类 -->
    <conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" />
    <conversionRule conversionWord="wex" converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter" />
    <conversionRule conversionWord="wEx" converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter" />
    <!-- 彩色日志格式 -->
    <property name="CONSOLE_LOG_PATTERN" value="${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}"/>

    <!--1. 输出到控制台-->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息-->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>debug</level>
        </filter>
        <encoder>
            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>
            <!-- 设置字符集 -->
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!--2. 输出到文档-->
    <!-- 2.1 level为 DEBUG 日志，时间滚动输出  -->
    <appender name="DEBUG_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文档的路径及文档名 -->
        <file>${logging.path}/web_debug.log</file>
        <!--日志文档输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志归档 -->
            <fileNamePattern>${logging.path}/web-debug-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文档保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文档只记录debug级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>debug</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 2.2 level为 INFO 日志，时间滚动输出  -->
    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文档的路径及文档名 -->
        <file>${logging.path}/web_info.log</file>
        <!--日志文档输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 每天日志归档路径以及格式 -->
            <fileNamePattern>${logging.path}/web-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文档保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文档只记录info级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>info</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 2.3 level为 WARN 日志，时间滚动输出  -->
    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文档的路径及文档名 -->
        <file>${logging.path}/web_warn.log</file>
        <!--日志文档输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${logging.path}/web-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文档保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文档只记录warn级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>warn</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 2.4 level为 ERROR 日志，时间滚动输出  -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文档的路径及文档名 -->
        <file>${logging.path}/web_error.log</file>
        <!--日志文档输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${logging.path}/web-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文档保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文档只记录ERROR级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!--
        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、
        以及指定<appender>。<logger>仅有一个name属性，
        一个可选的level和一个可选的addtivity属性。
        name:用来指定受此logger约束的某一个包或者具体的某一个类。
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，
              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。
              如果未设置此属性，那么当前logger将会继承上级的级别。
        addtivity:是否向上级logger传递打印信息。默认是true。
        <logger name="org.springframework.web" level="info"/>
        <logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/>
    -->

    <!--
        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：
        第一种把<root level="info">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息
        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：
        【logging.level.org.mybatis=debug logging.level.dao=debug】
     -->

    <!--
        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，
        不能设置为INHERITED或者同义词NULL。默认是DEBUG
        可以包含零个或多个元素，标识这个appender将会添加到这个logger。
    -->
    <!--过滤掉spring和mybatis的一些无用的DEBUG信息-->
    <logger name="org.springframework" level="INFO"></logger>
    <logger name="org.mybatis" level="INFO"></logger>
    <logger name="org.apache.zookeeper" level="INFO"></logger>

    <!-- 4. 最终的策略 -->
    <!-- 4.1 开发环境:打印控制台-->
    <springProfile name="dev">
        <logger name="com.dowin.globalvillage.controller" level="debug"/><!-- 修改此处扫描包名 -->
    </springProfile>

    <root level="debug">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="DEBUG_FILE" />
        <appender-ref ref="INFO_FILE" />
        <appender-ref ref="WARN_FILE" />
        <appender-ref ref="ERROR_FILE" />
    </root>

    4.2 生产环境:输出到文档
    <springProfile name="pro">
        <root level="info">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="DEBUG_FILE" />
            <appender-ref ref="INFO_FILE" />
            <appender-ref ref="ERROR_FILE" />
            <appender-ref ref="WARN_FILE" />
        </root>
    </springProfile>
</configuration>
```

## SpringBoot框架 | 拦截器应用：HandlerInterceptor

**拦截器用途**

拦截器是一种特殊的组件，可以在请求处理过程中对请求和响应进行拦截和处理。

拦截器可用于：权限控制、缓存处理、数据校验（登录验证）

**SpringBoot中实现拦截器完成登录验证**

```java
import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor {

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) {
            //当前拦截到的不是动态方法，直接放行
            return true;
        }
        
        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try {
            log.info("jwt校验:{}", token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            BaseContext.setCurrentId(empId);
            log.info("当前员工id：{}", empId);
            //3、通过，放行
            return true;
        } catch (Exception ex) {
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        }
    }
}
```



## SpringBoot框架 | 扩展MVC应用





# 项目报错处理

## java.io.EOFException: null

**问题描述**：

在使用redis获取缓存里面的值时，发生该错误

**问题排查：**

原本以为是Redis类型强转带来的问题。

原来的代码如下：

```java
Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
log.info("查询店铺营业状态为：{}", status == 1 ? "营业中" : "打烊中");
```

代码修改后如下：

```java
Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
if (status == null){
    return Result.error("无法获取店铺的营业状态");
}
log.info("查询店铺营业状态为：{}", status == 1 ? "营业中" : "打烊中");
```

依然报错。后来又经过努力回想，想起来修改过`redisTemplate`的序列化器。

原先的序列化器代码：

```java
@Bean
public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
    log.info("开始创建redis模板类...");
    // 创建RedisTemplate对象
    RedisTemplate<String, Object> template = new RedisTemplate<>();
    // 设置连接工厂
    template.setConnectionFactory(redisConnectionFactory);
    // 创建JSON序列化工具
    GenericJackson2JsonRedisSerializer jsonRedisSerializer =
            new GenericJackson2JsonRedisSerializer();
    // 设置Key的序列化
    template.setKeySerializer(RedisSerializer.string());
    template.setHashKeySerializer(RedisSerializer.string());
    // 设置Value的序列化
    template.setValueSerializer(jsonRedisSerializer);
    template.setHashValueSerializer(jsonRedisSerializer);
    // 返回
    return template;
}
```

修改后的：

```java
@Bean
public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
    log.info("开始创建redis模板类...");
    // 创建RedisTemplate对象
    RedisTemplate<String, Object> template = new RedisTemplate<>();
    // 设置连接工厂
    template.setConnectionFactory(redisConnectionFactory);
    template.setKeySerializer(new StringRedisSerializer());

    // 返回
    return template;
}
```

所以，问题的原因是：缓存里面的内容是序列化器修改之前存入的，在更改了序列化器之后，继续使用缓存里面的内容，导致出错。

正确的做法是：在修改了序列化器的内容后，应该将Redis中缓存的内容删除掉。



## 将jar包部署到docker中，不生成日志文件

基于SpringBoot创建的项目，默认采用Logback日志框架将相关信息输出到控制台。项目已经配置好`logback-spring.xml`配置文件，将输出到控制台的日志内容保存到文件中。经过验证，在开发阶段，可以输出日志。但是当把项目打包为jar包并部署到docker中的时候，没有正常生成日志文件。

原先关于java的docker编写文件如下：

```dockerfile
# 指定操作的镜像
FROM java:8
# 设定时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone
# 将jar包拷贝进去
RUN mkdir -p /sky_take_out/logs
COPY sky-server-1.0-SNAPSHOT.jar /sky_take_out/sky-server.jar
EXPOSE 8080

# 运行jar包
ENTRYPOINT ["java","-jar","/sky_take_out/sky-server.jar"]
```

通过docker compose部署后，发现不生成日志文件。

**经排查，发现原因是：**在jar包运行的时候，必须cd到jar包所在的目录下，然后运行springboot项目，才能生成日志文件。真是奇怪

修改后的文件内容：

```dockerfile
# 指定操作的镜像
FROM java:8
# 设定时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone
# 将jar包拷贝进去
RUN mkdir -p /sky_take_out/logs
COPY sky-server-1.0-SNAPSHOT.jar /sky_take_out/sky-server.jar
EXPOSE 8080

# 运行jar包
WORKDIR /sky_take_out
CMD ["java","-jar","sky-server.jar"]
```

修改的部分有：

- 指定工作目录（这个是关键）
- 将ENTRYPOINT改为CMD（这个应该不是必须的）

**问题补充：**

后又经过排查，发现不是不生成日志文件，而是：在什么路径下启动jar包，就在什么路径下生成日志文件。但是docker compose里面关于日志的挂载是以jar包所在的路径为基准，所以没有在虚拟机中看到有日志产生。



# 项目部署到Docker

## 遇到的问题

整体部署结构参考之前的I-CWP项目，仅在文件内容上进行些许微调

docker部署过程中，遇到的一些问题总结：



**Nginx | 问题1：**

在项目学习的时候，在win端通过nginx部署的前端静态文件。

win端和linux端关于nginx的目录结构不同，当时直接把win端的配置文件copy过来，用来linux端，导致第一次配置失败，花费一会时间查找原因

---

**Mysql | 问题1：**

项目学习的时候，给了数据库的sql文件，在win端导入Mysql中，没有出现问题。

在部署docker的时候，将上述sql文件按照给定配置方式导入docker mysql中，通过navicat查看数据的时候，发现有乱码。

最后是把win端mysql里面的数据，通过mysqldump导出sql文件，再用这个sql文件配置docker，成功！

---

**Redis | 问题1：**

说是问题，不如更多的说是感悟。

很多后端软件，通过docker部署的时候，都是通过配置文件实现，因此数据保存、端口开放、密码设置、log日志配置都可以在配置文件中找到响应配置项

---

**SpringBoot| 问题1：**

第一个问题就是配置日志文件的时候，项目运行了，没有生成日志文件。该问题已解决，解决方法在上一章：【项目报错处理】

**SpringBoot| 问题2：**

当初学习的时候就想着：nginx、redis、mysql用docker部署，然后在win上开发代码。当时自己给自己否了，觉得端口没法映射

现在部署的时候，具体想一想，是可以的：

- 若是在本机上，用浏览器网页访问项目，则请求的主体是自己的电脑，可以访问到本机地址
- 所以，nginx部署的时候，将通用url设置为：`localhost:8080`；redis、mysql正常设置
  - 浏览器通过访问：`192.168.93.128:88`，访问到前端项目的静态页面
  - 若点击相关按钮，本机浏览器向：`localhost:8080`发送请求，此时若项目在本机运行，是完全可以访问到的
  - 项目中关于redis、mysql的配置就写虚拟机的地址即可

**SpringBoot| 问题3：**

docker多容器部署项目的时候，加入网络和不加入网络，都可以访问到redis、mysql，因为做了端口映射。

但是直觉上：通过将所有容器加入到一个网络，然后通过容器名访问redis、mysql，应该要比通过访问虚拟机端口，再通过端口映射，访问到redis、mysql要快一些，有机会后续可以验证验证。



## 仍有的疑问

**问题描述**

我想将前端工程（通过nginx部署）、redis、mysql部署在虚拟机上，后端工程部署在本机。这样方便进行相关调试。

各自都完成了部署，但是联调还没实现。

做了如下操作：

- 本机（windows）开放防火墙端口
- 通过vmware，将虚拟机和本机做端口映射

不知道该怎么实现了，有空再说吧。
